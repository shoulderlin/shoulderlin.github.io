<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>PDF 合併與浮水印工具</title>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 2em;
      background: #f5f5f5;
    }
    label {
      display: block;
      margin-top: 1em;
    }
    input, select {
      width: 300px;
      padding: 0.5em;
      margin-top: 0.2em;
    }
    button {
      margin-top: 2em;
      padding: 0.8em 1.5em;
      font-size: 1em;
    }
  </style>
</head>
<body>
  <h1>PDF 合併工具（支援浮水印與頁碼）</h1>

  <label>選擇 PDF 檔案（可多選，支援調整順序）</label>
  <input type="file" id="pdfFiles" accept="application/pdf" multiple />

  <hr/>

  <h2>浮水印設定</h2>
  <label>內容</label>
  <input type="text" id="watermarkText" value="僅供內部使用" />
  <label>字型大小</label>
  <input type="number" id="watermarkFontSize" value="24" />
  <label>X 位置</label>
  <input type="number" id="watermarkX" value="100" />
  <label>Y 位置</label>
  <input type="number" id="watermarkY" value="100" />
  <label>顏色（CSS 格式）</label>
  <input type="text" id="watermarkColor" value="rgba(255,0,0,0.4)" />

  <hr/>

  <h2>頁碼設定</h2>
  <label>格式（使用 {page} 表示頁數）</label>
  <input type="text" id="pageNumberFormat" value="第 {page} 頁" />
  <label>字型大小</label>
  <input type="number" id="pageFontSize" value="12" />
  <label>X 位置</label>
  <input type="number" id="pageX" value="450" />
  <label>Y 位置</label>
  <input type="number" id="pageY" value="20" />
  <label>顏色（CSS 格式）</label>
  <input type="text" id="pageColor" value="black" />

  <button onclick="mergePDFs()">產生合併檔案</button>

  <script>
    async function mergePDFs() {
      const { PDFDocument, rgb, degrees, StandardFonts } = PDFLib;
      const files = Array.from(document.getElementById('pdfFiles').files);
      if (files.length === 0) return alert('請選擇至少一個 PDF 檔案');

      const mergedPdf = await PDFDocument.create();

      // 中文字型嵌入（Noto Sans TC）
      const fontBytes = await fetch("https://github.com/googlefonts/noto-cjk/raw/main/Sans/OTF/TraditionalChinese/NotoSansTC-Regular.otf").then(res => res.arrayBuffer());
      const customFont = await mergedPdf.embedFont(fontBytes);

      for (const file of files) {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await PDFDocument.load(arrayBuffer);
        const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());

        copiedPages.forEach((page, idx) => {
          mergedPdf.addPage(page);
        });
      }

      const watermarkText = document.getElementById('watermarkText').value;
      const watermarkFontSize = parseInt(document.getElementById('watermarkFontSize').value);
      const watermarkX = parseInt(document.getElementById('watermarkX').value);
      const watermarkY = parseInt(document.getElementById('watermarkY').value);
      const watermarkColor = document.getElementById('watermarkColor').value;

      const pageNumberFormat = document.getElementById('pageNumberFormat').value;
      const pageFontSize = parseInt(document.getElementById('pageFontSize').value);
      const pageX = parseInt(document.getElementById('pageX').value);
      const pageY = parseInt(document.getElementById('pageY').value);
      const pageColor = document.getElementById('pageColor').value;

      const pages = mergedPdf.getPages();
      pages.forEach((page, index) => {
        const { width, height } = page.getSize();

        // 浮水印
        if (watermarkText) {
          const { r, g, b, a } = parseCssColor(watermarkColor);
          page.drawText(watermarkText, {
            x: watermarkX,
            y: watermarkY,
            size: watermarkFontSize,
            font: customFont,
            color: rgb(r, g, b),
            opacity: a,
          });
        }

        // 頁碼
        const pageText = pageNumberFormat.replace('{page}', (index + 1));
        if (pageText) {
          const { r, g, b, a } = parseCssColor(pageColor);
          page.drawText(pageText, {
            x: pageX,
            y: pageY,
            size: pageFontSize,
            font: customFont,
            color: rgb(r, g, b),
            opacity: a,
          });
        }
      });

      const mergedPdfBytes = await mergedPdf.save();
      const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = '合併檔案.pdf';
      a.click();
      URL.revokeObjectURL(url);
    }

    function parseCssColor(css) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = css;
      const computed = ctx.fillStyle;
      const rgbaMatch = computed.match(/rgba?\((\d+), ?(\d+), ?(\d+)(?:, ?([\d.]+))?\)/);
      if (!rgbaMatch) return { r: 0, g: 0, b: 0, a: 1 };
      return {
        r: parseInt(rgbaMatch[1]) / 255,
        g: parseInt(rgbaMatch[2]) / 255,
        b: parseInt(rgbaMatch[3]) / 255,
        a: rgbaMatch[4] !== undefined ? parseFloat(rgbaMatch[4]) : 1,
      };
    }
  </script>
</body>
</html>
